<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stranger Things - 3D Gesture Interaction</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', sans-serif;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        /* 摄像头预览 - 左上角 */
        #video-container {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 200px;
            height: 150px;
            z-index: 10;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid rgba(255, 50, 50, 0.3);
            background: #000;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.2);
        }

        .video-input {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* 镜像翻转 */
        }

        /* UI 按钮 - 右上角 */
        #ui-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
            display: flex;
            gap: 10px;
        }

        button {
            background: rgba(40, 0, 0, 0.6);
            color: #ffcccc;
            border: 1px solid rgba(255, 100, 100, 0.4);
            padding: 6px 14px;
            cursor: pointer;
            border-radius: 4px;
            text-transform: uppercase;
            font-size: 12px;
            letter-spacing: 1px;
            transition: all 0.3s;
        }
        button:hover {
            background: rgba(100, 0, 0, 0.8);
            border-color: #ff0000;
        }

        /* 状态文字 - 底部居中 */
        #status-text {
            position: absolute;
            bottom: 40px;
            width: 100%;
            text-align: center;
            color: rgba(255, 200, 200, 0.9);
            z-index: 5;
            pointer-events: none;
            font-size: 1.4rem;
            text-shadow: 0 2px 10px #ff0000;
            letter-spacing: 3px;
            font-weight: 300;
            text-transform: uppercase;
        }
    </style>
    
    <!-- 1. 引入 Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    
    <!-- 2. 引入依赖库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    
    <!-- 关键修改：使用特定版本的 MediaPipe 以确保稳定性 -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="canvas-container"></div>
    
    <div id="video-container">
        <video class="video-input"></video>
    </div>
    
    <div id="ui-controls">
        <button id="btn-reset">RESET</button>
        <button id="btn-fullscreen">FULLSCREEN</button>
        <button id="btn-toggle-cam">CAM</button>
    </div>
    
    <div id="status-text">SYSTEM INITIALIZING...</div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- 全局配置 ---
        const CONFIG = {
            modelPath: 'public/model.glb',
            bgPath: 'public/background.png',
            
            cameraPos: { x: 0, y: 0, z: 20 },
            
            // 阶段 1：初始位置
            startPos: { x: 0, y: -7, z: -25 },
            
            // 阶段 2：悬停位置
            hoverPos: { x: 0, y: 0, z: -8 },
            
            // 交互：手势控制的高度范围
            yLimit: { min: -7, max: 15 },
            
            // 模型修正
            rotationOffset: { x: 0, y: -Math.PI / 2, z: 0 },
            targetSize: 8.0 
        };

        const STATE = {
            IDLE: 'IDLE',
            ASCENDING: 'ASCENDING',
            HOVERING_NEAR: 'HOVERING_NEAR',
            DISSOLVING: 'DISSOLVING'
        };

        let currentState = STATE.IDLE;
        
        let scene, camera, renderer;
        let modelContainer, mainModel; 
        let particleSystem;
        let bgMesh;
        let clock = new THREE.Clock();
        
        const videoElement = document.getElementsByClassName('video-input')[0];
        const statusDiv = document.getElementById('status-text');

        // --- 1. 场景初始化 ---
        function initScene() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.015);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(CONFIG.cameraPos.x, CONFIG.cameraPos.y, CONFIG.cameraPos.z);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.1;
            
            container.appendChild(renderer.domElement);

            // 灯光
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x220000, 1.5);
            scene.add(hemiLight);

            const dirLight = new THREE.DirectionalLight(0xffaa88, 2.0);
            dirLight.position.set(5, 10, 8);
            dirLight.castShadow = true;
            scene.add(dirLight);

            const rimLight = new THREE.SpotLight(0xff0000, 8.0);
            rimLight.position.set(-10, 5, -5);
            rimLight.lookAt(0,0,0);
            scene.add(rimLight);

            // 核心容器
            modelContainer = new THREE.Group();
            scene.add(modelContainer);

            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateBackgroundSize();
        }

        // --- 2. 资源加载 ---
        function loadAssets() {
            const manager = new THREE.LoadingManager();
            const texLoader = new THREE.TextureLoader(manager);
            const gltfLoader = new GLTFLoader(manager);

            manager.onLoad = () => statusDiv.innerText = "WAITING FOR HAND DETECTION...";

            // 背景
            texLoader.load(CONFIG.bgPath, (tex) => {
                tex.colorSpace = THREE.SRGBColorSpace;
                const mat = new THREE.MeshBasicMaterial({ 
                    map: tex, 
                    depthTest: false,
                    depthWrite: false,
                    fog: false 
                });
                bgMesh = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), mat);
                bgMesh.position.z = -60; 
                bgMesh.renderOrder = -1;
                scene.add(bgMesh);
                updateBackgroundSize();
            });

            // 模型
            gltfLoader.load(CONFIG.modelPath, (gltf) => {
                mainModel = gltf.scene;
                fitModel(mainModel);
                
                mainModel.traverse(c => {
                    if(c.isMesh) {
                        c.castShadow = true; 
                        c.receiveShadow = true;
                        if(c.material) {
                            c.material.roughness = 0.6;
                            c.material.metalness = 0.4;
                        }
                    }
                });

                modelContainer.add(mainModel);
                modelContainer.position.copy(CONFIG.startPos);
                
            }, undefined, (err) => statusDiv.innerText = "Error: model.glb not found");
        }

        function fitModel(model) {
            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());

            model.position.x -= center.x;
            model.position.y -= center.y;
            model.position.z -= center.z;

            const scale = CONFIG.targetSize / size.y;
            model.scale.set(scale, scale, scale);

            model.rotation.set(
                CONFIG.rotationOffset.x,
                CONFIG.rotationOffset.y,
                CONFIG.rotationOffset.z
            );
        }

        function updateBackgroundSize() {
            if (!bgMesh) return;
            const dist = camera.position.z - bgMesh.position.z;
            const height = 2 * Math.tan(THREE.MathUtils.degToRad(camera.fov) / 2) * dist;
            const width = height * camera.aspect;
            bgMesh.scale.set(width, height, 1);
        }

        // --- 3. 粒子特效 ---
        function triggerDissolve() {
            if (currentState !== STATE.HOVERING_NEAR) return;
            currentState = STATE.DISSOLVING;
            statusDiv.innerText = "STATUS: DISSOLVING...";
            
            const vertices = [];
            const colors = [];
            const velocities = [];
            const c1 = new THREE.Color(0xff3300); 
            const c2 = new THREE.Color(0x111111); 

            mainModel.traverse(c => {
                if(c.isMesh) {
                    const posAttr = c.geometry.attributes.position;
                    c.updateMatrixWorld(); 
                    const mat = c.matrixWorld;
                    
                    for(let i=0; i<posAttr.count; i+=3) {
                        const pt = new THREE.Vector3();
                        pt.fromBufferAttribute(posAttr, i);
                        pt.applyMatrix4(mat);
                        
                        vertices.push(pt.x, pt.y, pt.z);
                        
                        const col = Math.random()>0.5 ? c1 : c2;
                        colors.push(col.r, col.g, col.b);
                        
                        velocities.push(
                            (Math.random()-0.5)*5, 
                            Math.random()*4 + 1, 
                            (Math.random()-0.5)*5
                        );
                    }
                }
            });

            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geo.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 3));

            const mat = new THREE.ShaderMaterial({
                uniforms: { uTime: { value: 0 }, uSize: { value: 6.0 } },
                vertexShader: `
                    uniform float uTime;
                    uniform float uSize;
                    attribute vec3 velocity;
                    attribute vec3 color;
                    varying vec3 vColor;
                    varying float vAlpha;
                    void main() {
                        vColor = color;
                        vec3 pos = position + velocity * uTime;
                        pos.x += sin(uTime * 10.0 + position.y) * 0.2;
                        vec4 mv = modelViewMatrix * vec4(pos, 1.0);
                        gl_PointSize = uSize * (20.0 / -mv.z);
                        gl_Position = projectionMatrix * mv;
                        vAlpha = 1.0 - uTime * 0.4;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    varying float vAlpha;
                    void main() {
                        if (vAlpha <= 0.0) discard;
                        if (length(gl_PointCoord - 0.5) > 0.5) discard;
                        gl_FragColor = vec4(vColor, vAlpha);
                    }
                `,
                transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
            });

            particleSystem = new THREE.Points(geo, mat);
            scene.add(particleSystem);
            
            modelContainer.visible = false;
        }

        // --- 4. 重置逻辑 ---
        function resetGame() {
            if (particleSystem) {
                scene.remove(particleSystem);
                particleSystem.geometry.dispose();
                particleSystem.material.dispose();
                particleSystem = null;
            }
            modelContainer.visible = true;
            modelContainer.position.copy(CONFIG.startPos);
            currentState = STATE.IDLE;
            statusDiv.innerText = "STATE: IDLE - SHOW OPEN HAND";
        }

        // --- 5. 动画循环 ---
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            const time = clock.getElapsedTime();

            if (mainModel && modelContainer.visible) {
                const breath = Math.sin(time * 2) * 0.15;
                const shake = (Math.random() - 0.5) * 0.08;
                
                mainModel.position.y = breath + shake;
                mainModel.rotation.z = CONFIG.rotationOffset.z + (Math.random() - 0.5) * 0.05;
            }

            if (currentState === STATE.DISSOLVING && particleSystem) {
                particleSystem.material.uniforms.uTime.value += dt;
                if (particleSystem.material.uniforms.uTime.value > 3.0) {
                    resetGame();
                }
            }

            renderer.render(scene, camera);
        }

        // --- 6. 修复后的 MediaPipe 初始化逻辑 ---
        function setupMediaPipe() {
            // 关键修复：指定版本号，确保 WASM 和 TFLite 文件能从正确的 CDN 路径加载
            const MP_VERSION = '0.4.1646424915';
            
            const hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@${MP_VERSION}/${file}`;
                }
            });

            hands.setOptions({
                maxNumHands: 1, 
                modelComplexity: 1, // 1 = Lite/Full, 确保不会因为找不到 heavy model 而崩溃
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            
            hands.onResults(onResults);
            
            // 使用 Camera Utils，并添加错误处理
            const cam = new Camera(videoElement, {
                onFrame: async () => {
                    if(videoElement.videoWidth > 0) {
                        try {
                            await hands.send({image: videoElement});
                        } catch (e) {
                            console.warn("MediaPipe Frame Error:", e);
                        }
                    }
                },
                width: 320, 
                height: 240
            });
            cam.start();
        }

        // 判定手势
        function isHandOpen(lm) {
            const tips = [8, 12, 16, 20];
            const pips = [6, 10, 14, 18];
            let open = 0;
            for(let i=0; i<4; i++) if(lm[tips[i]].y < lm[pips[i]].y) open++;
            return open >= 3;
        }

        function isFist(lm) {
            const tips = [8, 12, 16, 20];
            const pips = [6, 10, 14, 18];
            let closed = 0;
            for(let i=0; i<4; i++) if(lm[tips[i]].y > lm[pips[i]].y) closed++;
            return closed >= 3;
        }

        function onResults(results) {
            if (!modelContainer || currentState === STATE.DISSOLVING) return;

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                const palmY = lm[0].y; 
                const handHeightRatio = Math.max(0, Math.min(1, 1 - palmY)); 

                switch(currentState) {
                    case STATE.IDLE:
                        statusDiv.innerText = "STATE: IDLE - HAND DETECTED";
                        if (isHandOpen(lm)) currentState = STATE.ASCENDING;
                        break;

                    case STATE.ASCENDING:
                        statusDiv.innerText = "STATE: RISING - RAISE HAND & FIST";
                        
                        const targetY = THREE.MathUtils.mapLinear(
                            handHeightRatio, 
                            0.2, 0.8, 
                            CONFIG.yLimit.min, CONFIG.yLimit.max
                        );

                        // 平滑控制
                        modelContainer.position.y = THREE.MathUtils.lerp(modelContainer.position.y, targetY, 0.1);

                        // 握拳触发
                        if (modelContainer.position.y > 8 && isFist(lm)) {
                            triggerHover();
                        }
                        break;

                    case STATE.HOVERING_NEAR:
                        statusDiv.innerText = "STATE: HOVERING - OPEN HAND TO DISSOLVE";
                        if (isHandOpen(lm)) triggerDissolve();
                        break;
                }
            } else {
                // 如果手丢了，保持 IDLE 提示
                if(currentState === STATE.IDLE) {
                    statusDiv.innerText = "STATE: IDLE - SHOW OPEN HAND";
                }
            }
        }

        function triggerHover() {
            currentState = STATE.HOVERING_NEAR;
            
            gsap.to(modelContainer.position, {
                x: CONFIG.hoverPos.x,
                y: CONFIG.hoverPos.y,
                z: CONFIG.hoverPos.z,
                duration: 1.2,
                ease: "power2.out"
            });
        }

        // --- UI ---
        document.getElementById('btn-reset').onclick = () => location.reload();
        document.getElementById('btn-fullscreen').onclick = () => {
            !document.fullscreenElement ? document.documentElement.requestFullscreen() : document.exitFullscreen();
        };
        document.getElementById('btn-toggle-cam').onclick = () => {
            const el = document.getElementById('video-container');
            el.style.display = el.style.display === 'none' ? 'block' : 'none';
        };

        // --- 启动 ---
        initScene();
        loadAssets();
        setupMediaPipe(); // 此处已包含版本修复
        animate();

    </script>
</body>
</html>